<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Foguetinho - Crash Game (Protótipo)</title>
  <meta name="theme-color" content="#000000" />
  <link rel="manifest" href="/manifest.json" />
    <style>
  body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 0; background: #000000; color: #e6e8f0; }
      header { display: flex; align-items: center; justify-content: space-between; padding: 12px 16px; background: #0f1530; border-bottom: 1px solid #1b2448; }
      .container { padding: 16px; max-width: 960px; margin: 0 auto; }
      .row { display: flex; flex-wrap: wrap; gap: 16px; }
      .card { background: #0f1530; border: 1px solid #1b2448; border-radius: 8px; padding: 12px; flex: 1; min-width: 280px; }
      .title { font-size: 14px; opacity: .8; margin-bottom: 8px; }
      .big { font-size: 48px; font-weight: 700; color: #7cf3a0; }
      input, button, select { background: #0b1026; border: 1px solid #223064; color: #e6e8f0; padding: 8px 10px; border-radius: 6px; }
      button { cursor: pointer; }
  .btn { transition: transform .06s ease, box-shadow .06s ease; }
  .btn:active { transform: scale(0.98); box-shadow: 0 0 0 2px rgba(124,243,160,.2) inset; }
      table { width: 100%; border-collapse: collapse; }
      th, td { border-bottom: 1px solid #1b2448; padding: 6px 8px; }
      .success { color: #7cf3a0; }
      .danger { color: #ff6b6b; }
    </style>
  </head>
  <body>
    <header>
      <div>Foguetinho</div>
      <div style="display:flex; gap:12px; align-items:center">
        <div id="onlineBox" style="font-size:12px; opacity:.8"></div>
        <div id="serverBox" style="font-size:12px; opacity:.8"></div>
        <div id="userBox"></div>
        <button id="changeServerBtn" style="font-size:12px">Trocar servidor</button>
      </div>
    </header>
    <div class="container">
      <div class="row">
        <div class="card" style="flex:2">
          <div class="title">Multiplicador</div>
          <div id="mult" class="big">1.00x</div>
          <canvas id="chart" width="600" height="180" style="width:100%; max-width: 100%; background:#0b1026; border-radius:6px; border:1px solid #1b2448"></canvas>
          <div id="countdown" class="muted"></div>
          <div style="margin-top:8px">
            <input id="betAmount" type="number" min="1" value="10" style="width:120px" aria-label="Valor da aposta" />
            <button id="betBtn" class="btn">Apostar</button>
            <button id="cashoutBtn" disabled class="btn">Sacar</button>
            <button id="resetBtn" class="btn" title="Reseta seu saldo para 10">Resetar saldo</button>
          </div>
          <div id="status" style="margin-top:8px; min-height: 24px;"></div>
        </div>
        <div class="card">
          <div class="title">Ranking (Top 10)</div>
          <table>
            <thead>
              <tr><th>Nome</th><th>Saldo</th></tr>
            </thead>
            <tbody id="ranking"></tbody>
          </table>
        </div>
      </div>
    </div>

    <script>
      // Define o backend por: ?server= | localStorage | mesma origem | localhost
      const params = new URLSearchParams(location.search);
      const defaultBase = location.protocol.startsWith('http') ? `${location.protocol}//${location.host}` : 'http://localhost:3001';
      const savedBase = localStorage.getItem('foguetinho_server');
      const apiBase = (params.get('server') || savedBase || defaultBase).replace(/\/+$/,'');
      if (params.get('server')) localStorage.setItem('foguetinho_server', apiBase);

      function showServer() {
        const el = document.getElementById('serverBox');
        if (el) el.textContent = `Servidor: ${apiBase}`;
      }

      function changeServer() {
        const val = prompt('URL do servidor (ex: https://foguetinho-1.onrender.com):', apiBase);
        if (!val) return;
        const cleaned = val.replace(/\/+$/,'');
        localStorage.setItem('foguetinho_server', cleaned);
        const url = new URL(location.href);
        url.searchParams.set('server', cleaned);
        location.href = url.toString();
      }

      async function refreshOnline() {
        try {
          const r = await fetch(apiBase + '/api/online');
          const d = await r.json();
          if (r.ok) {
            const el = document.getElementById('onlineBox');
            if (el) el.textContent = `Online: ${d.online}`;
          }
        } catch {}
      }
      let user = null;
      let ws = null;
      let currentBetId = null;
      let nextStartAt = null;
      const cvs = document.getElementById('chart');
      const ctx = cvs.getContext('2d');
      // Offscreen para grade; reduz redesenhos custosos
      const gridCanvas = document.createElement('canvas');
      const gridCtx = gridCanvas.getContext('2d');
      let lastGridWindowSec = null;
      let lastGridMaxM = null;
      let dpr = Math.min(2, window.devicePixelRatio || 1);

      let roundStart = performance.now();
      let lastTick = { t: 0, m: 1 };
      let currTick = { t: 0, m: 1 };
      let currTickTime = performance.now();
      let pathPoints = []; // pontos confirmados por tick
      let crashed = false;
      // A largura horizontal passa a ajustar dinamicamente conforme o tempo de rodada

      function setupCanvas() {
        const rect = cvs.getBoundingClientRect();
        dpr = Math.min(2, window.devicePixelRatio || 1);
        // evita canvas gigantes: limita DPR a 2
        cvs.width = Math.max(320, Math.floor(rect.width * dpr));
        cvs.height = Math.floor(200 * dpr);
        gridCanvas.width = cvs.width;
        gridCanvas.height = cvs.height;
        lastGridWindowSec = null;
        lastGridMaxM = null;
      }

      function resetRound() {
        roundStart = performance.now();
        lastTick = { t: 0, m: 1 };
        currTick = { t: 0, m: 1 };
        currTickTime = performance.now();
        pathPoints = [{ t: 0, m: 1 }];
        crashed = false;
      }

      function onTickUpdate(mult) {
        const t = Math.max(0, (performance.now() - roundStart) / 1000);
        lastTick = currTick;
        currTick = { t, m: mult };
        currTickTime = performance.now();
        pathPoints.push(currTick);
  if (pathPoints.length > 800) pathPoints.shift();
      }

      function drawGrid(windowSec, maxM) {
        const w = gridCanvas.width, h = gridCanvas.height;
        const g = gridCtx;
        g.clearRect(0,0,w,h);
        // eixos
        g.strokeStyle = '#223064';
        g.lineWidth = 1 * dpr;
        g.beginPath();
        g.moveTo(40*dpr, h-20*dpr); g.lineTo(w-10*dpr, h-20*dpr);
        g.moveTo(40*dpr, h-20*dpr); g.lineTo(40*dpr, 10*dpr);
        g.stroke();
        // funções de mapeamento p/ grid
        function y(m){ const denom = Math.max(1, (maxM-1)); return (h-20*dpr) - (h-40*dpr) * (m-1) / denom; }
        function x(t){ return 40*dpr + (w-60*dpr) * (t / windowSec); }
        // grades Y em potências de 2
        g.strokeStyle = '#1b2448';
        g.fillStyle = '#7a86b6';
        g.font = `${11*dpr}px system-ui`;
        for (let m=1; m<=maxM; m*=2) {
          const yy = y(m);
          g.beginPath(); g.moveTo(40*dpr, yy); g.lineTo(w-10*dpr, yy); g.stroke();
          g.save(); g.scale(dpr, dpr);
          g.fillText('x'+m.toFixed(0), 8, Math.max(12, yy/dpr-2));
          g.restore();
        }
        // grades X a cada 10s
        for (let t=0; t<=windowSec; t+=10) {
          const xx = x(t);
          g.beginPath(); g.moveTo(xx, h-20*dpr); g.lineTo(xx, 10*dpr); g.stroke();
          g.save(); g.scale(dpr, dpr);
          g.fillText(t+'s', Math.max(42, xx/dpr-8), h/dpr-6);
          g.restore();
        }
      }

      let __lastFrame = 0;
      function render() {
        const w = cvs.width, h = cvs.height;
        const nowTs = performance.now();
        // throttle ~30fps
        if (nowTs - __lastFrame < 33) { requestAnimationFrame(render); return; }
        __lastFrame = nowTs;
        ctx.clearRect(0,0,w,h);
        // posição da ponta (interpola entre ticks)
        const now = nowTs;
        const alpha = Math.min(1, (now - currTickTime) / 100);
        const tipT = lastTick.t + (currTick.t - lastTick.t) * alpha;
        const tipM = lastTick.m + (currTick.m - lastTick.m) * alpha;
        // janela dinâmica (10s..60s)
        const lastT = pathPoints.length ? pathPoints[pathPoints.length-1].t : 0;
        const tRef = Math.max(tipT, lastT);
        const windowSec = Math.min(60, Math.max(10, Math.ceil(tRef / 10) * 10));
        // Y em potências de 2
        const rawMaxM = Math.max(2, ...pathPoints.map(p=>p.m), tipM);
        let pow = 1; while (pow * 2 < rawMaxM) pow *= 2;
        const maxM = Math.max(2, pow * 2);
        // redesenha grade só quando necessário
        if (lastGridWindowSec !== windowSec || lastGridMaxM !== maxM) {
          drawGrid(windowSec, maxM);
          lastGridWindowSec = windowSec; lastGridMaxM = maxM;
        }
        ctx.drawImage(gridCanvas, 0, 0);
        // funções de mapeamento
        function x(t){ return 40*dpr + (w-60*dpr) * (t / windowSec); }
        function y(m){ const denom = Math.max(1, (maxM-1)); return (h-20*dpr) - (h-40*dpr) * (m-1) / denom; }
        // pontos + decimação para limitar custo no mobile
        const pts = [...pathPoints, { t: tipT, m: tipM }];
        const maxSeg = 400; const step = Math.max(1, Math.ceil(pts.length / maxSeg));
        if (pts.length > 1) {
          ctx.strokeStyle = crashed ? '#ff6b6b' : '#ff5277';
          ctx.lineWidth = 2 * dpr;
          ctx.lineJoin = 'round'; ctx.lineCap = 'round';
          ctx.beginPath();
          ctx.moveTo(x(pts[0].t), y(pts[0].m));
          for (let i=1;i<pts.length;i+=step) ctx.lineTo(x(pts[i].t), y(pts[i].m));
          const last = pts[pts.length-1];
          ctx.lineTo(x(last.t), y(last.m));
          ctx.stroke();

          // ponta e label
          const xf = x(last.t), yf = y(last.m);
          ctx.fillStyle = crashed ? '#ff6b6b' : '#ff5277';
          ctx.beginPath(); ctx.arc(xf, yf, 3*dpr, 0, Math.PI*2); ctx.fill();
          ctx.save(); ctx.scale(dpr, dpr);
          ctx.fillStyle = '#e6e8f0'; ctx.font = '12px system-ui';
          ctx.fillText(`${tipM.toFixed(2)}x`, Math.min(w/dpr-50, xf/dpr+6), Math.max(12, yf/dpr-6));
          ctx.restore();

          if (crashed) {
            ctx.strokeStyle = '#ff6b6b';
            ctx.beginPath();
            ctx.moveTo(xf-8*dpr, yf-8*dpr); ctx.lineTo(xf+8*dpr, yf+8*dpr);
            ctx.moveTo(xf-8*dpr, yf+8*dpr); ctx.lineTo(xf+8*dpr, yf-8*dpr);
            ctx.stroke();
          }
        }
        requestAnimationFrame(render);
      }

      async function signup() {
        const name = localStorage.getItem('foguetinho_name') || prompt('Seu nome:');
        localStorage.setItem('foguetinho_name', name);
        const res = await fetch(apiBase + '/api/signup', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ name }) });
        user = await res.json();
        document.getElementById('userBox').textContent = `${user.name} — Saldo: ${user.balance}`;
        refreshRanking();
      }

      async function refreshRanking() {
        const res = await fetch(apiBase + '/api/ranking');
        const list = await res.json();
        const tbody = document.getElementById('ranking');
        tbody.innerHTML = '';
        list.slice(0,10).forEach(u => {
          const tr = document.createElement('tr');
          tr.innerHTML = `<td>${u.name}</td><td>${u.balance}</td>`;
          tbody.appendChild(tr);
        });
      }

      function connectWS() {
        const wsProto = apiBase.startsWith('https') ? 'wss' : 'ws';
        const wsHost = apiBase.replace(/^https?:\/\//, '');
        ws = new WebSocket(`${wsProto}://${wsHost}`);
        ws.onmessage = (ev) => {
          const msg = JSON.parse(ev.data);
          if (msg.type === 'tick') {
            document.getElementById('mult').textContent = msg.multiplier.toFixed(2) + 'x';
            onTickUpdate(msg.multiplier);
          } else if (msg.type === 'round_end') {
            document.getElementById('status').textContent = `Rodada acabou em ${msg.crashAt.toFixed(2)}x`;
            document.getElementById('cashoutBtn').disabled = true;
            currentBetId = null;
            refreshRanking();
            crashed = true;
            nextStartAt = msg.nextStartAt || null;
            if (nextStartAt) startCountdown();
          } else if (msg.type === 'round_start') {
            crashed = false;
            resetRound();
          } else if (msg.type === 'bet_placed') {
            if (msg.userId === user.id) {
              document.getElementById('status').textContent = `Apostou ${msg.amount}`;
              document.getElementById('cashoutBtn').disabled = false;
              user.balance -= msg.amount;
              document.getElementById('userBox').textContent = `${user.name} — Saldo: ${user.balance}`;
            }
          } else if (msg.type === 'cashout') {
            if (msg.userId === user.id) {
              document.getElementById('status').textContent = `Sacou em ${msg.atMultiplier.toFixed(2)}x ( +${msg.payout} )`;
              user.balance = msg.balance;
              document.getElementById('userBox').textContent = `${user.name} — Saldo: ${user.balance}`;
              document.getElementById('cashoutBtn').disabled = true;
              currentBetId = null;
            }
            refreshRanking();
          }
        };
        ws.onopen = () => console.log('WS connected');
        ws.onclose = () => setTimeout(connectWS, 1000);
      }
      function startCountdown() {
        const el = document.getElementById('countdown');
  const timer = setInterval(() => {
          const ms = Math.max(0, nextStartAt - Date.now());
          const s = Math.ceil(ms/1000);
          el.textContent = s > 0 ? `Próxima rodada em ${s}s` : '';
          if (ms <= 0) { clearInterval(timer); el.textContent = ''; }
  }, 500);
      }

      async function placeBet() {
        const amount = parseInt(document.getElementById('betAmount').value, 10);
        const res = await fetch(apiBase + '/api/bet', {
          method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ userId: user.id, amount })
        });
        const data = await res.json();
        if (res.ok) {
          currentBetId = data.betId;
          user.balance = data.newBalance;
          document.getElementById('userBox').textContent = `${user.name} — Saldo: ${user.balance}`;
        } else {
          alert(data.error || 'Erro');
        }
      }

      async function cashout() {
        if (!currentBetId) return;
        const multText = document.getElementById('mult').textContent;
        const atMultiplier = parseFloat(multText);
        const res = await fetch(apiBase + '/api/cashout', {
          method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ userId: user.id, betId: currentBetId, atMultiplier })
        });
        const data = await res.json();
        if (!res.ok) alert(data.error || 'Erro ao sacar');
      }

  document.getElementById('betBtn').addEventListener('click', placeBet);
  document.getElementById('cashoutBtn').addEventListener('click', cashout);
  document.getElementById('changeServerBtn').addEventListener('click', changeServer);
      document.getElementById('resetBtn').addEventListener('click', async () => {
        if (!user?.id) return;
        const res = await fetch(apiBase + '/api/reset-balance', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ userId: user.id }) });
        const data = await res.json();
        if (res.ok) {
          user.balance = data.balance;
          document.getElementById('userBox').textContent = `${user.name} — Saldo: ${user.balance}`;
          refreshRanking();
          document.getElementById('status').textContent = 'Saldo resetado para 10';
        } else {
          alert(data.error || 'Erro ao resetar saldo');
        }
      });

  showServer();
  // configurar canvas responsivo
  function _resize() { setupCanvas(); }
  window.addEventListener('resize', () => { clearTimeout(window.__rTo); window.__rTo = setTimeout(_resize, 150); });
  _resize();
  signup().then(() => { connectWS(); setInterval(refreshRanking, 5000); setInterval(refreshOnline, 5000); refreshOnline(); requestAnimationFrame(render); });

      // Registra Service Worker para tornar PWA instalável (requer HTTPS ou localhost)
      if ('serviceWorker' in navigator) {
        navigator.serviceWorker.register('/sw.js').catch(console.error);
      }
    </script>
  </body>
</html>
